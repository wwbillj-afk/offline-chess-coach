<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Play vs Coach — final</title>
<link rel="manifest" href="/manifest.json">
<style>
  :root{
    --bg-top:#081826; --bg-bottom:#031020;
    --glass1: rgba(255,255,255,0.04);
    --glass2: rgba(255,255,255,0.01);
    --sq-light:#e7f6fc; --sq-dark:#2f4655;
    --accent:#6fc23b; --muted:#9fb1c7;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg-top),var(--bg-bottom));font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;color:#eaf6ff}
  header{padding:16px;text-align:center;font-weight:800;font-size:20px}
  .app{display:flex;height:calc(100vh - 56px);gap:12px;padding:10px;box-sizing:border-box}
  .left{flex:1;display:flex;flex-direction:column;align-items:center}

  .board-frame{width:94vw;max-width:520px;padding:14px;border-radius:18px;background:linear-gradient(180deg,var(--glass1),var(--glass2));box-shadow:0 22px 60px rgba(0,0,0,0.65);display:flex;align-items:center;justify-content:center}
  #board{width:92vw;max-width:480px;aspect-ratio:1/1;display:grid;grid-template-columns:repeat(8,1fr);border-radius:12px;overflow:hidden;border:5px solid rgba(0,0,0,0.08);position:relative}
  .square{display:flex;align-items:center;justify-content:center;user-select:none;touch-action:manipulation;position:relative}
  .light{background:linear-gradient(180deg,var(--sq-light),#cfeaf7)}
  .dark{background:linear-gradient(180deg,var(--sq-dark),#2b4958)}
  .selected{outline:5px solid rgba(111,194,59,0.36);box-shadow:0 12px 28px rgba(0,0,0,0.45)}
  .last-from::after,.last-to::after{content:"";position:absolute;inset:0;border-radius:inherit;background:linear-gradient(180deg,rgba(255,255,255,0.01),rgba(111,194,59,0.05));mix-blend-mode:overlay;opacity:0.9}
  .pulse{animation:pulseMove 520ms ease}
  @keyframes pulseMove{0%{transform:scale(.9);opacity:.6}60%{transform:scale(1.06);opacity:1}100%{transform:scale(1);opacity:1}}
  .piece{font-size:calc(20px + 2.6vw);line-height:0.95;-webkit-font-smoothing:antialiased;text-shadow:0 6px 12px rgba(0,0,0,0.55),0 1px 0 rgba(255,255,255,0.04);transition:transform 160ms ease}
  .white-piece{color:#ffffff}
  .black-piece{color:#071218;text-shadow:0 6px 12px rgba(0,0,0,0.55),0 1px 0 rgba(255,255,255,0.03)}
  .controls{display:flex;gap:12px;align-items:center;margin-top:14px;width:100%;max-width:760px}
  .btn{padding:10px 14px;border-radius:12px;border:none;background:#1f2937;color:#eaf6ff;cursor:pointer;box-shadow:0 8px 18px rgba(0,0,0,0.5)}
  .btn.primary{background:var(--accent);color:#04210b;font-weight:800}
  .statusSmall{font-weight:700;color:var(--muted)}

  /* coach panel */
  .coach{width:360px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));border-left:1px solid rgba(255,255,255,0.03);display:flex;flex-direction:column;padding:12px;border-radius:10px}
  .coachHeader{display:flex;gap:12px;align-items:center;padding-bottom:8px;border-bottom:1px solid rgba(255,255,255,0.03)}
  .avatar{width:52px;height:52px;border-radius:50%;background:linear-gradient(135deg,#f472b6,#fb7185);display:flex;align-items:center;justify-content:center;color:#07102a;font-weight:700}
  .coachBody{flex:1;overflow:auto;padding-top:8px}
  .coachLine{margin-bottom:12px;font-size:15px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);padding:8px;border-radius:8px}
  .coachFooter{display:flex;gap:8px;padding-top:8px;border-top:1px solid rgba(255,255,255,0.03)}

  /* pregame modal */
  .modal { position: fixed; inset: 0; display:flex; align-items:center; justify-content:center; background: rgba(2,6,13,0.6); z-index: 9999; }
  .panel{ width: min(96vw,720px); background: linear-gradient(180deg,#0b1726,#071123); border-radius:12px; padding:16px; box-shadow: 0 30px 80px rgba(0,0,0,0.7); color:#eaf6ff }
  .row{ display:flex; gap:12px; align-items:center; margin-bottom:10px; flex-wrap:wrap }
  label{ color:#cfe8f6; font-weight:600 }
  .field{ background:#081826; padding:8px 10px; border-radius:8px; border:1px solid rgba(255,255,255,0.03); color:#eaf6ff }
  select, input[type="range"]{ background:transparent; color:inherit; border:none; outline:none }
  .small{ font-size:13px; color:#9fb1c7 }
  .startBtn{ margin-top:10px; display:inline-block; padding:10px 16px; border-radius:10px; background:var(--accent); color:#03170a; font-weight:800; cursor:pointer; border:none }
  @media(max-width:900px){ .coach{display:none} }
</style>
</head>
<body>

<header>Play vs Coach</header>

<div class="app">
  <div class="left">
    <div class="board-frame">
      <div id="board" class="board" aria-label="Chessboard"></div>
    </div>

    <div class="controls">
      <button class="btn" id="openSetupBtn">Setup</button>
      <button class="btn" id="resetBtn">Reset</button>
      <button class="btn primary" id="flipBtn">Flip</button>
      <div style="flex:1"></div>
      <div id="statusSmall" class="statusSmall">Coach: Ready</div>
    </div>
  </div>

  <div class="coach" id="coachPanel">
    <div class="coachHeader">
      <div class="avatar">♛</div>
      <div>
        <div style="font-weight:800" id="coachName">Coach</div>
        <div style="font-size:13px;color:#a9c3d6">Friendly teacher</div>
      </div>
    </div>

    <div id="coachBody" class="coachBody"></div>

    <div class="coachFooter">
      <button class="btn" id="whyBtn">Why?</button>
      <button class="btn" id="toggleCoachBtn">Collapse</button>
    </div>
  </div>
</div>

<!-- Pregame modal -->
<div id="setupModal" class="modal" style="display:flex">
  <div class="panel">
    <h2 style="margin:0 0 8px 0">Game setup</h2>
    <div class="row">
      <label>Side</label>
      <div class="field">
        <select id="sideSelect">
          <option value="white">Play as White</option>
          <option value="black">Play as Black</option>
          <option value="random">Random</option>
        </select>
      </div>

      <label>Difficulty</label>
      <div class="field" style="min-width:200px;display:flex;align-items:center;gap:8px">
        <input id="difficulty" type="range" min="0" max="100" value="30">
        <div id="diffLabel" class="small">30</div>
      </div>
    </div>

    <div class="row">
      <label>Timer</label>
      <div class="field">
        <select id="timerSelect">
          <option value="none">No timer (default)</option>
          <option value="3+0">3 | 0</option>
          <option value="5+0">5 | 0</option>
          <option value="10+0">10 | 0</option>
        </select>
      </div>

      <label>Coach assist</label>
      <div class="field">
        <select id="assistSelect">
          <option value="on">Assistance ON</option>
          <option value="off">Assistance OFF</option>
        </select>
      </div>
    </div>

    <div class="row small">
      <div>Difficulty maps to bot strength. Lower = more random; higher = deeper lookahead.</div>
    </div>

    <div style="display:flex;gap:12px;justify-content:flex-end;">
      <button class="btn" id="cancelSetup">Cancel</button>
      <button class="startBtn" id="startGameBtn">Start Game</button>
    </div>
  </div>
</div>

<script>
/* FINAL PLAY.HTML LOGIC
 - Board rendering (Unicode fallback)
 - Pregame setup (side, difficulty, timer, assist)
 - Coach plays moves (using chess.js if available, else random-legal fallback)
 - Attempts multiple CDNs for chess.js
 - All in a single file; replace play.html fully
*/

/* --- Basic board state model (0 = a8 ... 63 = h1) --- */
const PIECES = { r:'♜', n:'♞', b:'♝', q:'♛', k:'♚', p:'♟', R:'♖', N:'♘', B:'♗', Q:'♕', K:'♔', P:'♙' };

let pos = [
  'r','n','b','q','k','b','n','r',
  'p','p','p','p','p','p','p','p',
  '','','','','','','','',
  '','','','','','','','',
  '','','','','','','','',
  '','','','','','','','',
  'P','P','P','P','P','P','P','P',
  'R','N','B','Q','K','B','N','R'
];

let flipped = false;
let selected = null;
let lastMove = { from:null, to:null };

/* DOM refs */
const boardEl = document.getElementById('board');
const coachBody = document.getElementById('coachBody');
const statusSmall = document.getElementById('statusSmall');
const setupModal = document.getElementById('setupModal');
const startGameBtn = document.getElementById('startGameBtn');
const openSetupBtn = document.getElementById('openSetupBtn');
const cancelSetup = document.getElementById('cancelSetup');
const sideSelect = document.getElementById('sideSelect');
const difficulty = document.getElementById('difficulty');
const diffLabel = document.getElementById('diffLabel');
const assistSelect = document.getElementById('assistSelect');
const timerSelect = document.getElementById('timerSelect');

/* player / bot roles */
let humanColor = 'w'; // 'w' or 'b'
let botColor = 'b';
let assistanceOn = true;
let timerSetting = 'none';
let difficultyValue = 30;

/* chess.js support */
let ChessJS = null; // will be set if chess.js loaded
let chessGame = null; // chess.js instance

/* helper: log from coach */
function coachSay(text){
  const d = document.createElement('div');
  d.className = 'coachLine';
  d.innerHTML = `<strong>Coach:</strong> ${text}`;
  coachBody.appendChild(d);
  coachBody.scrollTop = coachBody.scrollHeight;
  statusSmall.textContent = 'Coach: ' + text;
}

/* draw board with highlights */
function drawBoard(){
  boardEl.innerHTML = '';
  const indices = [...Array(64).keys()];
  if(flipped) indices.reverse();
  for(const idx of indices){
    const r = Math.floor(idx/8), c = idx%8;
    const div = document.createElement('div');
    div.className = 'square ' + (((r+c)%2) ? 'dark' : 'light');
    div.dataset.idx = idx;
    if(lastMove.from === idx) div.classList.add('last-from');
    if(lastMove.to === idx) div.classList.add('last-to');
    const piece = pos[idx];
    if(piece){
      const s = document.createElement('div');
      s.className = 'piece ' + (piece === piece.toUpperCase() ? 'white-piece' : 'black-piece');
      s.textContent = PIECES[piece] || '?';
      s.style.transform = 'scale(.98)';
      setTimeout(()=>s.style.transform='scale(1)', 30);
      div.appendChild(s);
    }
    if(selected === idx) div.classList.add('selected');
    div.addEventListener('click', ()=>onSquareClick(Number(div.dataset.idx)));
    boardEl.appendChild(div);
  }
}

/* click handler */
function onSquareClick(idx){
  // if game managed by chess.js, guard with legal checks handled later
  if (!gameRunning) { coachSay('Start a game first.'); return; }

  if (selected === null) {
    if (!pos[idx] || pieceColor(pos[idx]) !== humanColor) { coachSay('Tap your piece first.'); return; }
    selected = idx; drawBoard(); coachSay('Selected ' + idxToAlg(idx)); return;
  }
  if (selected === idx) { selected = null; drawBoard(); coachSay('Selection cleared.'); return; }

  // try to move (use chess.js if available to validate)
  const fromAlg = idxToAlg(selected), toAlg = idxToAlg(idx);
  if (ChessJSisReady()) {
    const moveObj = { from: fromAlg, to: toAlg, promotion: 'q' };
    const result = chessGame.move(moveObj);
    if (result === null) { coachSay('Illegal move. Try again.'); return; }
    // update pos from chessGame.fen()
    syncFromChessJS();
    lastMove = { from: selected, to: idx };
    animateTarget(idx);
    selected = null; drawBoard();
    coachSay(`${playerName} played ${result.san}`);
    // after a short delay let bot move if it's its turn
    setTimeout(()=>maybeBotMove(), 450);
  } else {
    // fallback naive move (no enforcement): commit and let bot respond
    pos[idx] = pos[selected]; pos[selected] = '';
    lastMove = { from: selected, to: idx };
    selected = null; drawBoard(); coachSay(`${playerName} moved ${fromAlg}→${toAlg}`);
    setTimeout(()=>maybeBotMove(), 450);
  }
}

/* helpers */
function idxToAlg(i){ return String.fromCharCode(97 + (i%8)) + (8 - Math.floor(i/8)); }
function algToIdx(a){ return (8 - Number(a[1]))*8 + (a.charCodeAt(0)-97); }
function pieceColor(p){ if (!p) return null; return p === p.toUpperCase() ? 'w' : 'b'; }

/* animate */
function animateTarget(idx){
  const el = [...boardEl.children].find(ch => Number(ch.dataset.idx) === idx);
  if(!el) return;
  el.classList.add('pulse');
  setTimeout(()=>el.classList.remove('pulse'), 520);
}

/* sync pos[] from chess.js FEN */
function syncFromChessJS(){
  if (!ChessJSisReady()) return;
  const fen = chessGame.fen(); // e.g. rnbqkbnr/pppppppp/8/8/8/8/PPPP...
  const rows = fen.split(' ')[0].split('/');
  const newPos = [];
  for(const row of rows){
    for(const ch of row){
      if (isFinite(ch)) {
        for(let i=0;i<Number(ch);i++) newPos.push('');
      } else {
        newPos.push(ch);
      }
    }
  }
  pos = newPos;
}

/* Game running flag */
let gameRunning = false;

/* BOT move controller */
async function maybeBotMove(){
  if (!gameRunning) return;
  // if chess.js active, ask it whose turn; else infer from pos counts
  const botTurn = ChessJSisReady() ? (chessGame.turn() === (botColor==='w'?'w':'b')) : isBotTurnFallback();
  if (!botTurn) return;
  // Coach move
  coachSay('Coach is thinking...');
  await sleep(200 + Math.round(Math.random()*400));
  if (ChessJSisReady()) {
    // use chess.js + simple minimax based on difficulty
    const move = computeBestMoveJS(difficultyValue);
    if (move) {
      chessGame.move(move);
      syncFromChessJS();
      // compute lastMove indices
      lastMove.from = algToIdx(move.from);
      lastMove.to = algToIdx(move.to);
      drawBoard(); animateTarget(lastMove.to);
      coachSay(`Coach played ${move.san || move.from + '-' + move.to}`);
      setTimeout(()=>{ if (isHumanTurn()) coachSay('Your move.'); }, 200);
    } else {
      coachSay('Coach has no legal moves.');
    }
  } else {
    // fallback: random legal-like move
    const mv = randomFallbackMove();
    if (mv) {
      pos[mv.to] = pos[mv.from];
      pos[mv.from] = '';
      lastMove = { from: mv.from, to: mv.to };
      drawBoard(); animateTarget(lastMove.to);
      coachSay('Coach moved.');
    } else {
      coachSay('Coach cannot move.');
    }
  }
}

/* Is it human's turn when no chess.js? Decide by material counts parity */
function isBotTurnFallback(){
  // count pieces of white and black to approximate side to move:
  // We'll track lastMove and alternate — but simpler: use moveCount parity stored in gameRunningMoveCount
  if (typeof gameRunningMoveCount === 'undefined') gameRunningMoveCount = 0;
  const sideToMove = (gameRunningMoveCount % 2 === 0) ? 'w' : 'b';
  return (sideToMove === botColor);
}

/* increment move count on every human move (fallback) */
let gameRunningMoveCount = 0;

/* is it human's turn? */
function isHumanTurn(){
  if (ChessJSisReady()) return chessGame.turn() === (humanColor==='w'?'w':'b');
  return !isBotTurnFallback();
}

/* computeBestMoveJS: uses chess.js legal moves + minimax with depth mapping */
function computeBestMoveJS(diff){
  // Map diff to search depth
  let depth;
  if (diff < 25) depth = 0;          // random among legal moves
  else if (diff < 50) depth = 1;
  else if (diff < 75) depth = 2;
  else depth = 3; // be careful with mobile performance

  const moves = chessGame.moves({ verbose: true });
  if (!moves || moves.length === 0) return null;

  if (depth === 0) {
    // choose a reasonably good move heuristically: prefer captures; otherwise random
    const captures = moves.filter(m => m.captured);
    if (captures.length) return randomChoice(captures);
    return randomChoice(moves);
  }

  // minimax with alpha-beta, returning best move object
  const maximizingColor = (chessGame.turn() === (botColor==='w'?'w':'b')) ? (botColor==='w' ? 'w' : 'b') : (botColor==='w'?'w':'b');

  let bestMove = null;
  let bestScore = -Infinity;
  const start = Date.now();
  for (const m of moves) {
    chessGame.move({ from: m.from, to: m.to, promotion: m.promotion || 'q' });
    const score = -negamax(chessGame, depth - 1, -Infinity, Infinity);
    chessGame.undo();
    if (score > bestScore) { bestScore = score; bestMove = m; }
    // small timeout to avoid lock on very slow devices
    if (Date.now() - start > 1200 && depth >= 3) break;
  }
  return bestMove;
}

/* negamax simple with material eval */
function negamax(game, depth, alpha, beta) {
  if (depth === 0) return evaluateMaterial(game);

  const moves = game.moves({ verbose: true });
  if (moves.length === 0) {
    // mate or stalemate
    if (game.in_check()) return -999999;
    return 0;
  }

  let max = -Infinity;
  for (const m of moves) {
    game.move({ from: m.from, to: m.to, promotion: m.promotion || 'q' });
    const val = -negamax(game, depth - 1, -beta, -alpha);
    game.undo();
    if (val > max) max = val;
    if (val > alpha) alpha = val;
    if (alpha >= beta) break;
  }
  return max;
}

/* simple material evaluation */
function evaluateMaterial(game) {
  const pieceValue = { p: 100, n: 320, b: 330, r: 500, q: 900, k: 20000 };
  const board = game.board(); // 8x8
  let score = 0;
  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const sq = board[r][c];
      if (!sq) continue;
      const val = pieceValue[sq.type] || 0;
      score += sq.color === 'w' ? val : -val;
    }
  }
  // if bot plays black, invert sign so higher is better for bot
  return (botColor === 'w') ? score : -score;
}

/* fallback random-but-legal-like move generator (simple piece moves, no special rules) */
function randomFallbackMove(){
  // collect all pieces belonging to botColor
  const positions = [];
  for (let i=0;i<64;i++){
    if (pos[i] && pieceColor(pos[i]) === botColor) positions.push(i);
  }
  const candidates = [];
  for (const from of positions){
    const p = pos[from].toLowerCase();
    const dirs = simpleDirsForPiece(p);
    for (const d of dirs){
      const to = from + d;
      if (to < 0 || to >= 64) continue;
      // ensure same row for horizontal moves: naive check
      if (Math.abs((from%8)-(to%8)) > 2 && Math.abs(d) % 8 !== 0) continue;
      if (!pos[to] || pieceColor(pos[to]) !== botColor) candidates.push({from,to});
    }
  }
  if (candidates.length === 0) return null;
  return randomChoice(candidates);
}

/* simple direction offsets for approximate moves (not fully legal, basic coverage) */
function simpleDirsForPiece(p){
  if (p === 'p') return [-8, -16, -7, -9]; // pawn (black/white confusion but okay approx)
  if (p === 'n') return [-17,-15,-10,-6,6,10,15,17];
  if (p === 'b') return [-9,-7,7,9];
  if (p === 'r') return [-8,-1,1,8];
  if (p === 'q') return [-9,-8,-7,-1,1,7,8,9];
  if (p === 'k') return [-9,-8,-7,-1,1,7,8,9];
  return [];
}

/* helpers */
function randomChoice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

/* --- Load chess.js from multiple CDNs (graceful) --- */
async function tryLoadChessJS(){
  const candidates = [
    'https://unpkg.com/chess.js@1.0.0/chess.min.js',
    'https://cdn.jsdelivr.net/npm/chess.js@1.0.0/chess.min.js',
    'https://cdn.jsdelivr.net/npm/chess.js@0.13.4/chess.min.js'
  ];
  for (const url of candidates){
    try {
      await loadScript(url);
      if (typeof Chess !== 'function' && typeof Chess !== 'object') continue;
      ChessJS = Chess;
      chessGame = new ChessJS();
      coachSay('Local chess library loaded.');
      return true;
    } catch(e){
      console.log('chess.js load failed', url, e);
    }
  }
  coachSay('No chess engine CDN reachable; using fallback moves.');
  return false;
}

/* script loader */
function loadScript(url){
  return new Promise((resolve,reject)=>{
    const s = document.createElement('script');
    s.src = url;
    s.onload = ()=>resolve(url);
    s.onerror = ()=>reject(url);
    document.head.appendChild(s);
  });
}

function ChessJSisReady(){ return !!chessGame && !!ChessJS; }

/* sync initial pos array to chess.js if loaded */
function syncToChessJS(){
  if (!ChessJSisReady()) return;
  // build FEN from pos[]
  const rows = [];
  for (let r=0;r<8;r++){
    let empty = 0
